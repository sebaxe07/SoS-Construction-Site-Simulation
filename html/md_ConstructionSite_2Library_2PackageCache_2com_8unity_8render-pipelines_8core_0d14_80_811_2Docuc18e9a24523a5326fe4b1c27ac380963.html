<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: Writing a render pipeline</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">Writing a render pipeline</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md1633"></a></p>
<p>This page covers the process of how to use the RenderGraph API to write a render pipeline. For information about the RenderGraph API, see <a class="el" href="md_ConstructionSite_2Library_2PackageCache_2com_8unity_8render-pipelines_8core_0d14_80_811_2Docu3ddec3843f8a91a5bd24ec3b3f724d2d.html">render graph system</a> and <a class="el" href="md_ConstructionSite_2Library_2PackageCache_2com_8unity_8render-pipelines_8core_0d14_80_811_2Docud1e34df70a46a90bfd8d2cbc3c591bb2.html">render graph fundamentals</a>.</p>
<h2><a class="anchor" id="autotoc_md1634"></a>
Initialization and cleanup of Render Graph</h2>
<p>To begin, your render pipeline needs to maintain at least one instance of <a href="../api/UnityEngine.Experimental.Rendering.RenderGraphModule.RenderGraph.html">RenderGraph</a>. This is the main entry point for the API. You can use more than one instance of a render graph, but be aware that <a class="el" href="namespaceUnity.html">Unity</a> does not share resources across <code>RenderGraph</code> instances so for optimal memory usage, only use one instance.</p>
<div class="fragment"><div class="line"><span class="preprocessor"> #</span></div>
<div class="line"><span class="keyword">using </span>UnityEngine.Experimental.Rendering.RenderGraphModule;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span> <span class="keyword">class </span>MyRenderPipeline : RenderPipeline</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="classUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1RenderGraph.html">RenderGraph</a> m_RenderGraph;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> InitializeRenderGraph()</div>
<div class="line">    {</div>
<div class="line">        m_RenderGraph = <span class="keyword">new</span> <a class="code hl_class" href="classUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1RenderGraph.html">RenderGraph</a>(“MyRenderGraph”);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> CleanupRenderGraph()</div>
<div class="line">    {</div>
<div class="line">        m_RenderGraph.<a class="code hl_function" href="classUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1RenderGraph.html#a3cebb3e1096c146fe6ea58c20c64fb3f">Cleanup</a>();</div>
<div class="line">          m_RenderGraph = null;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclassUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1RenderGraph_html"><div class="ttname"><a href="classUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1RenderGraph.html">UnityEngine.Experimental.Rendering.RenderGraphModule.RenderGraph</a></div><div class="ttdoc">This class is the main entry point of the Render Graph system.</div><div class="ttdef"><b>Definition</b> RenderGraph.cs:220</div></div>
<div class="ttc" id="aclassUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1RenderGraph_html_a3cebb3e1096c146fe6ea58c20c64fb3f"><div class="ttname"><a href="classUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1RenderGraph.html#a3cebb3e1096c146fe6ea58c20c64fb3f">UnityEngine.Experimental.Rendering.RenderGraphModule.RenderGraph.Cleanup</a></div><div class="ttdeci">void Cleanup()</div><div class="ttdoc">Cleanup the Render Graph.</div><div class="ttdef"><b>Definition</b> RenderGraph.cs:386</div></div>
</div><!-- fragment --><p>To initialize a <code>RenderGraph</code> instance, call the constructor with an optional name to identify the render graph. This also registers a render graph-specific panel in the SRP Debug window which is useful for debugging the RenderGraph instance. When you dispose of a render pipeline, call the <code>Cleanup()</code> method on the RenderGraph instance to properly free all the resources the render graph allocated.</p>
<h2><a class="anchor" id="autotoc_md1635"></a>
Starting a render graph</h2>
<p>Before you add any render passes to the render graph, you first need to initialize the render graph. To do this, call the <code>RecordAndExecute</code> method. This method will return a disposable struct of type <code>RenderGraphExecution</code> that you can use with a scope. When the <code>RenderGraphExecution</code> struct exits the scope or its Dispose function is called, the render graph is executed. This pattern ensures that the render graph is always executed correctly even in the case of an exception during the recording of the graph. For details about this method's parameters, see the <a href="../api/UnityEngine.Experimental.Rendering.RenderGraphModule.RenderGraph.html">API documentation</a></p>
<div class="fragment"><div class="line"><span class="preprocessor"> #</span></div>
<div class="line">var renderGraphParams = <span class="keyword">new</span> RenderGraphExecuteParams()</div>
<div class="line">{</div>
<div class="line">    scriptableRenderContext = renderContext,</div>
<div class="line">    commandBuffer = cmd,</div>
<div class="line">    currentFrameIndex = frameIndex</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using</span> (m_RenderGraph.<a class="code hl_function" href="classUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1RenderGraph.html#ab26f01b30edccb4d2ba5883421340273">RecordAndExecute</a>(renderGraphParams))</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Add your passes here</span></div>
<div class="line">}</div>
<div class="ttc" id="aclassUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1RenderGraph_html_ab26f01b30edccb4d2ba5883421340273"><div class="ttname"><a href="classUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1RenderGraph.html#ab26f01b30edccb4d2ba5883421340273">UnityEngine.Experimental.Rendering.RenderGraphModule.RenderGraph.RecordAndExecute</a></div><div class="ttdeci">RenderGraphExecution RecordAndExecute(in RenderGraphParameters parameters)</div><div class="ttdoc">Starts the recording of the the render graph and then automatically execute when the return value goe...</div><div class="ttdef"><b>Definition</b> RenderGraph.cs:653</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1636"></a>
Creating resources for the render graph</h2>
<p>When you use a render graph, you never directly allocate resources yourself. Instead, the RenderGraph instance handles the allocation and disposal of its own resources. To declare resources and use them in a render pass, you use render graph specific APIs that return handles to the resource.</p>
<p>There are two main types of resources that a render graph uses:</p>
<ul>
<li><b>Internal resources</b>: These resources are internal to a render graph execution and you cannot access them outside of the RenderGraph instance. You also cannot pass these resources from one execution of a graph to another. The render graph handles the lifetime of these resources.</li>
<li><b>Imported resources</b>: These usually come from outside the render graph execution. Typical examples are the back buffer (provided by the camera) or buffers that you want the graph to use across multiple frames for temporal effects (like using the camera color buffer for temporal anti-aliasing). You are responsible for handling the lifetime of these resources.</li>
</ul>
<p>After you create or import a resource, the render graph system represents it as a resource type-specific handle (<code>TextureHandle</code>, <code>ComputeBufferHandle</code>, or <code>RendererListHandle</code>). This way, the render graph can use internal and imported resources in the same way in all of its APIs.</p>
<div class="fragment"><div class="line"><span class="preprocessor"> #</span></div>
<div class="line"><span class="keyword">public</span> <a class="code hl_struct" href="structUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1TextureHandle.html">TextureHandle</a> <a class="code hl_class" href="classUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1RenderGraph.html">RenderGraph</a>.<a class="code hl_function" href="classUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1RenderGraph.html#a52b03077017a036a3b11864e67f7c7ed">CreateTexture</a>(in <a class="code hl_struct" href="structUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1TextureDesc.html">TextureDesc</a> desc);</div>
<div class="line"><span class="keyword">public</span> <a class="code hl_struct" href="structUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1ComputeBufferHandle.html">ComputeBufferHandle</a> <a class="code hl_class" href="classUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1RenderGraph.html">RenderGraph</a>.<a class="code hl_function" href="classUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1RenderGraph.html#a05ded8a7fd2f045c9697795cdf469886">CreateComputeBuffer</a>(in <a class="code hl_struct" href="structUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1ComputeBufferDesc.html">ComputeBufferDesc</a> desc)</div>
<div class="line"><span class="keyword">public</span> <a class="code hl_struct" href="structUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1RendererListHandle.html">RendererListHandle</a> <a class="code hl_class" href="classUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1RenderGraph.html">RenderGraph</a>.<a class="code hl_function" href="classUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1RenderGraph.html#a92afcf81d3b60e82bf82bf310f11db63">CreateRendererList</a>(in RendererListDesc desc);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span> <a class="code hl_struct" href="structUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1TextureHandle.html">TextureHandle</a> <a class="code hl_class" href="classUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1RenderGraph.html">RenderGraph</a>.<a class="code hl_function" href="classUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1RenderGraph.html#af94ac2654a10825ba5d1bd33fbfae218">ImportTexture</a>(RTHandle rt);</div>
<div class="line"><span class="keyword">public</span> <a class="code hl_struct" href="structUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1TextureHandle.html">TextureHandle</a> <a class="code hl_class" href="classUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1RenderGraph.html">RenderGraph</a>.<a class="code hl_function" href="classUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1RenderGraph.html#a02fdfd125621f8faed18201f8dab99bc">ImportBackbuffer</a>(RenderTargetIdentifier rt);</div>
<div class="line"><span class="keyword">public</span> <a class="code hl_struct" href="structUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1ComputeBufferHandle.html">ComputeBufferHandle</a> <a class="code hl_class" href="classUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1RenderGraph.html">RenderGraph</a>.<a class="code hl_function" href="classUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1RenderGraph.html#ae635e9178f9c88184d2eeca6aa243a6a">ImportComputeBuffer</a>(ComputeBuffer computeBuffer);</div>
<div class="ttc" id="aclassUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1RenderGraph_html_a02fdfd125621f8faed18201f8dab99bc"><div class="ttname"><a href="classUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1RenderGraph.html#a02fdfd125621f8faed18201f8dab99bc">UnityEngine.Experimental.Rendering.RenderGraphModule.RenderGraph.ImportBackbuffer</a></div><div class="ttdeci">TextureHandle ImportBackbuffer(RenderTargetIdentifier rt)</div><div class="ttdoc">Import the final backbuffer to render graph.</div><div class="ttdef"><b>Definition</b> RenderGraph.cs:470</div></div>
<div class="ttc" id="aclassUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1RenderGraph_html_a05ded8a7fd2f045c9697795cdf469886"><div class="ttname"><a href="classUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1RenderGraph.html#a05ded8a7fd2f045c9697795cdf469886">UnityEngine.Experimental.Rendering.RenderGraphModule.RenderGraph.CreateComputeBuffer</a></div><div class="ttdeci">ComputeBufferHandle CreateComputeBuffer(in ComputeBufferDesc desc)</div><div class="ttdoc">Create a new Render Graph Compute Buffer resource.</div><div class="ttdef"><b>Definition</b> RenderGraph.cs:580</div></div>
<div class="ttc" id="aclassUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1RenderGraph_html_a52b03077017a036a3b11864e67f7c7ed"><div class="ttname"><a href="classUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1RenderGraph.html#a52b03077017a036a3b11864e67f7c7ed">UnityEngine.Experimental.Rendering.RenderGraphModule.RenderGraph.CreateTexture</a></div><div class="ttdeci">TextureHandle CreateTexture(in TextureDesc desc)</div><div class="ttdoc">Create a new Render Graph Texture resource.</div><div class="ttdef"><b>Definition</b> RenderGraph.cs:480</div></div>
<div class="ttc" id="aclassUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1RenderGraph_html_a92afcf81d3b60e82bf82bf310f11db63"><div class="ttname"><a href="classUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1RenderGraph.html#a92afcf81d3b60e82bf82bf310f11db63">UnityEngine.Experimental.Rendering.RenderGraphModule.RenderGraph.CreateRendererList</a></div><div class="ttdeci">RendererListHandle CreateRendererList(in CoreRendererListDesc desc)</div><div class="ttdoc">Creates a new Renderer List Render Graph resource.</div><div class="ttdef"><b>Definition</b> RenderGraph.cs:559</div></div>
<div class="ttc" id="aclassUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1RenderGraph_html_ae635e9178f9c88184d2eeca6aa243a6a"><div class="ttname"><a href="classUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1RenderGraph.html#ae635e9178f9c88184d2eeca6aa243a6a">UnityEngine.Experimental.Rendering.RenderGraphModule.RenderGraph.ImportComputeBuffer</a></div><div class="ttdeci">ComputeBufferHandle ImportComputeBuffer(ComputeBuffer computeBuffer)</div><div class="ttdoc">Import an external Compute Buffer to the Render Graph Any pass writing to an imported compute buffer ...</div><div class="ttdef"><b>Definition</b> RenderGraph.cs:570</div></div>
<div class="ttc" id="aclassUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1RenderGraph_html_af94ac2654a10825ba5d1bd33fbfae218"><div class="ttname"><a href="classUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1RenderGraph.html#af94ac2654a10825ba5d1bd33fbfae218">UnityEngine.Experimental.Rendering.RenderGraphModule.RenderGraph.ImportTexture</a></div><div class="ttdeci">TextureHandle ImportTexture(RTHandle rt)</div><div class="ttdoc">Import an external texture to the Render Graph. Any pass writing to an imported texture will be consi...</div><div class="ttdef"><b>Definition</b> RenderGraph.cs:460</div></div>
<div class="ttc" id="astructUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1ComputeBufferDesc_html"><div class="ttname"><a href="structUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1ComputeBufferDesc.html">UnityEngine.Experimental.Rendering.RenderGraphModule.ComputeBufferDesc</a></div><div class="ttdoc">Descriptor used to create compute buffer resources.</div><div class="ttdef"><b>Definition</b> RenderGraphResourceComputeBuffer.cs:43</div></div>
<div class="ttc" id="astructUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1ComputeBufferHandle_html"><div class="ttname"><a href="structUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1ComputeBufferHandle.html">UnityEngine.Experimental.Rendering.RenderGraphModule.ComputeBufferHandle</a></div><div class="ttdoc">Compute Buffer resource handle.</div><div class="ttdef"><b>Definition</b> RenderGraphResourceComputeBuffer.cs:12</div></div>
<div class="ttc" id="astructUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1RendererListHandle_html"><div class="ttname"><a href="structUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1RendererListHandle.html">UnityEngine.Experimental.Rendering.RenderGraphModule.RendererListHandle</a></div><div class="ttdoc">Renderer List resource handle.</div><div class="ttdef"><b>Definition</b> RenderGraphResourceRendererList.cs:16</div></div>
<div class="ttc" id="astructUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1TextureDesc_html"><div class="ttname"><a href="structUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1TextureDesc.html">UnityEngine.Experimental.Rendering.RenderGraphModule.TextureDesc</a></div><div class="ttdoc">Descriptor used to create texture resources.</div><div class="ttdef"><b>Definition</b> RenderGraphResourceTexture.cs:92</div></div>
<div class="ttc" id="astructUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1TextureHandle_html"><div class="ttname"><a href="structUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1TextureHandle.html">UnityEngine.Experimental.Rendering.RenderGraphModule.TextureHandle</a></div><div class="ttdoc">Texture resource handle.</div><div class="ttdef"><b>Definition</b> RenderGraphResourceTexture.cs:12</div></div>
</div><!-- fragment --><p>The main ways to create resources are described above, but there are variations of these functions. For the complete list, see the <a href="../api/UnityEngine.Experimental.Rendering.RenderGraphModule.RenderGraph.html">API documentation</a>. Note that the specific function to use to import the camera back buffer is <code>RenderTargetIdentifier</code>.</p>
<p>To create resources, each API requires a descriptor structure as a parameter. The properties in these structures are similar to the properties in the resources they represent (respectively <a class="el" href="md_ConstructionSite_2Library_2PackageCache_2com_8unity_8render-pipelines_8core_0d14_80_811_2Documentation_0i_2rthandle-system.html">RTHandle</a>, <a href="https://docs.unity3d.com/ScriptReference/ComputeBuffer.html">ComputeBuffer</a>, and <a href="../api/UnityEngine.Experimental.Rendering.RendererList.html">RendererLists</a>). However, some properties are specific to render graph textures.</p>
<p>Here are the most important ones:</p>
<ul>
<li><b>clearBuffer</b>: This property tells the graph whether to clear the buffer when the graph creates it. This is how you should clear textures when using the render graph. This is important because a render graph pools resources, which means any pass that creates a texture might get an already existing one with undefined content.</li>
<li><b>clearColor</b>: This property stores the color to clear the buffer to, if applicable.</li>
</ul>
<p>There are also two notions specific to textures that a render graph exposes through the <code>TextureDesc</code> constructors:</p>
<ul>
<li><b>xrReady</b>: This boolean indicates to the graph whether this texture is for XR rendering. If true, the render graph creates the texture as an array for rendering into each XR eye.</li>
<li><b>dynamicResolution</b>: This boolean indicates to the graph whether it needs to dynamically resize this texture when the application uses dynamic resolution. If false, the texture does not scale automatically.</li>
</ul>
<p>You can create resources outside render passes, inside the setup code for a render pass, but not in the rendering code.</p>
<p>Creating a resource outside of all render passes can be useful for cases where the first pass uses a given resource that depends on logic in the code that might change regularly. In this case, you must create the resource before any of those passes. A good example is using the color buffer for either a deferred lighting pass or a forward lighting pass. Both of these passes write to the color buffer, but <a class="el" href="namespaceUnity.html">Unity</a> only executes one of them depending on the current rendering path chosen for the camera. In this case, you would create the color buffer outside both passes and pass it to the correct one as a parameter.</p>
<p>Creating a resource inside a render pass is usually for resources the render pass produces itself. For example, a blur pass requires an already existing input texture, but creates the output itself and returns it at the end of the render pass.</p>
<p>Note that creating a resource like that does not allocate GPU memory every frame. Instead, the render graph system reuses pooled memory. In the context of the render graph, think of resource creation more in terms of data flow in the context of a render pass than actual allocation. If a render pass creates a whole new output then it “creates” a new texture in the render graph.</p>
<h2><a class="anchor" id="autotoc_md1637"></a>
Writing a render pass</h2>
<p>Before <a class="el" href="namespaceUnity.html">Unity</a> can execute the render graph, you must declare all the render passes. You write a render pass in two parts: setup and rendering.</p>
<h3><a class="anchor" id="autotoc_md1638"></a>
Setup</h3>
<p>During setup, you declare the render pass and all the data it needs to execute. The render graph represents data by a class specific to the render pass that contains all the relevant properties. These can be regular C# constructs (struct, PoDs, etc) and render graph resource handles. This data structure is accessible during the actual rendering code.</p>
<div class="fragment"><div class="line"><span class="preprocessor"> #</span></div>
<div class="line"><span class="keyword">class </span>MyRenderPassData</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">public</span> <span class="keywordtype">float</span> parameter;</div>
<div class="line">    <span class="keyword">public</span> <a class="code hl_struct" href="structUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1TextureHandle.html">TextureHandle</a> inputTexture;</div>
<div class="line">    <span class="keyword">public</span> <a class="code hl_struct" href="structUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1TextureHandle.html">TextureHandle</a> outputTexture;</div>
<div class="line">}</div>
</div><!-- fragment --><p>After you define the pass data, you can then declare the render pass itself:</p>
<div class="fragment"><div class="line"><span class="preprocessor"> #</span></div>
<div class="line"><span class="keyword">using</span> (var builder = renderGraph.AddRenderPass&lt;MyRenderPassData&gt;(<span class="stringliteral">&quot;My Render Pass&quot;</span>, out var passData))</div>
<div class="line">{</div>
<div class="line">        passData.parameter = 2.5f;</div>
<div class="line">    passData.inputTexture = builder.ReadTexture(inputTexture);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_struct" href="structUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1TextureHandle.html">TextureHandle</a> output = renderGraph.CreateTexture(<span class="keyword">new</span> <a class="code hl_struct" href="structUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1TextureDesc.html">TextureDesc</a>(Vector2.one, <span class="keyword">true</span>, <span class="keyword">true</span>)</div>
<div class="line">                        { colorFormat = GraphicsFormat.R8G8B8A8_UNorm, clearBuffer = true, clearColor = Color.black, name = <span class="stringliteral">&quot;Output&quot;</span> });</div>
<div class="line">    passData.outputTexture = builder.WriteTexture(output);</div>
<div class="line"> </div>
<div class="line">    builder.SetRenderFunc(myFunc); <span class="comment">// details below.</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>You define the render pass in the <code>using</code> scope around the <code>AddRenderPass</code> function. At the end of the scope, the render graph adds the render pass to the internal structures of the render graph for later processing.</p>
<p>The <code>builder</code> variable is an instance of <code>RenderGraphBuilder</code>. This is the entry point to build the information relating to the render pass. There are several important parts to this:</p>
<ul>
<li><b>Declaring resource usage</b>: This is one of the most important aspects of the RenderGraph API. Here you explicitly declare whether the render pass needs read and/or write access to the resources. This allows the render graph to have an overall view of the whole rendering frame and thus determine the best use of GPU memory and synchronization points between various render passes.</li>
<li><b>Declaring the rendering function</b>: This is the function in which you call graphics commands. It receives the pass data you define for the render pass as a parameter as well as the render graph context. You set the rendering function for a render pass via <code>SetRenderFunc</code> and the function runs after the graph compiles.</li>
<li><b>Creating transient resources</b>: Transient, or internal, resources are resources you create for the duration of this render pass only. You create them in the builder rather than the render graph itself to reflect their lifetime. Creating transient resources uses the same parameters as the equivalent function in the RenderGraph APIs. This is particularly useful when a pass uses temporary buffers that should not be accessible outside of the pass. Outside the pass where you declare a transient resource, the handle to the resource becomes invalid and <a class="el" href="namespaceUnity.html">Unity</a> throws errors if you try to use it.</li>
</ul>
<p>The <code>passData</code> variable is an instance of the type you provide when you declare the pass. This is where you set the data that the rendering code can access. Note that the render graph does not use the contents of <code>passData</code> right away, but later in the frame, after it registers all the passes and the render graph compiles and executes. This means that any reference the <code>passData</code> stores must be constant across the whole frame. Otherwise, if you change the content before the render pass executes, it does not contain the correct content during the render pass. For this reason, it is best practice to only store value types in the <code>passData</code> unless you are certain that a reference stays constant until the pass finishes execution.</p>
<p>For an overview of the <code>RenderGraphBuilder</code> APIs, see the below table. For more details, see the API documentation:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function   </th><th class="markdownTableHeadNone">Purpose    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">TextureHandle ReadTexture(in TextureHandle input)   </td><td class="markdownTableBodyNone">Declares that the render pass reads from the <code>input</code> texture you pass into the function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">TextureHandle WriteTexture(in TextureHandle input)   </td><td class="markdownTableBodyNone">Declares that the render pass writes to the <code>input</code> texture you pass into the function.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">TextureHandle UseColorBuffer(in TextureHandle input, int index)   </td><td class="markdownTableBodyNone">Same as <code>WriteTexture</code> but also automatically binds the texture as a render texture at the provided binding index at the beginning of the pass.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">TextureHandle UseDepthBuffer(in TextureHandle input, DepthAccess flags)   </td><td class="markdownTableBodyNone">Same as <code>WriteTexture</code> but also automatically binds the texture as a depth texture with the access flags you pass into the function.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">TextureHandle CreateTransientTexture(in TextureDesc desc)   </td><td class="markdownTableBodyNone">Create a transient texture. This texture exists for the duration of the pass.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">RendererListHandle UseRendererList(in RendererListHandle input)   </td><td class="markdownTableBodyNone">Declares that this render pass uses the Renderer List you pass in. The render pass uses the <code>RendererList.Draw</code> command to render the list.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ComputeBufferHandle ReadComputeBuffer(in ComputeBufferHandle input)   </td><td class="markdownTableBodyNone">Declares that the render pass reads from the <code>input</code> ComputeBuffer you pass into the function.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">ComputeBufferHandle WriteComputeBuffer(in ComputeBufferHandle input)   </td><td class="markdownTableBodyNone">Declares that the render pass writes to the <code>input</code> Compute Buffer you pass into the function.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ComputeBufferHandle CreateTransientComputeBuffer(in ComputeBufferDesc desc)   </td><td class="markdownTableBodyNone">Create a transient Compute Buffer. This texture exists for the duration of the Compute Buffer.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">void SetRenderFunc&lt;PassData&gt;(RenderFunc&lt;PassData&gt; renderFunc) where PassData : class, new()   </td><td class="markdownTableBodyNone">Set the rendering function for the render pass.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">void EnableAsyncCompute(bool value)   </td><td class="markdownTableBodyNone">Declares that the render pass runs on the asynchronous compute pipeline.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">void AllowPassCulling(bool value)   </td><td class="markdownTableBodyNone">Specifies whether <a class="el" href="namespaceUnity.html">Unity</a> should cull the render pass (default is true). This can be useful when the render pass has side effects and you never want the render graph system to cull.   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md1639"></a>
Rendering Code</h3>
<p>After you complete the setup, you can declare the function to use for rendering via the <code>SetRenderFunc</code> method on the <code>RenderGraphBuilder</code>. The function you assign must use the following signature:</p>
<div class="fragment"><div class="line"><span class="preprocessor"> #</span></div>
<div class="line">delegate <span class="keywordtype">void</span> RenderFunc&lt;PassData&gt;(PassData data, <a class="code hl_class" href="classUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1RenderGraphContext.html">RenderGraphContext</a> renderGraphContext) where PassData : <span class="keyword">class</span>, <span class="keyword">new</span>();</div>
<div class="ttc" id="aclassUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1RenderGraphContext_html"><div class="ttname"><a href="classUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1RenderGraphContext.html">UnityEngine.Experimental.Rendering.RenderGraphModule.RenderGraphContext</a></div><div class="ttdoc">This class specifies the context given to every render pass.</div><div class="ttdef"><b>Definition</b> RenderGraph.cs:31</div></div>
</div><!-- fragment --><p>You can either pass a render function as a <code>static</code> function or a lambda. The benefit of using a lambda function is that it can bring better code clarity because the rendering code is next to the setup code.</p>
<p>Note that if you use a lambda, be very careful not to capture any parameters from the main scope of the function as that generates garbage, which <a class="el" href="namespaceUnity.html">Unity</a> later locates and frees during garbage collection. If you use Visual Studio and hover over the arrow **=&gt;**, it tells you if the lambda captures anything from the scope. Avoid accessing members or member functions because using either captures <code>this</code>.</p>
<p>The render function takes two parameters:</p>
<ul>
<li><code>PassData data</code>: This data is of the type you pass in when you declare the render pass. This is where you can access the properties initialized during the setup phase and use them for the rendering code.</li>
<li><code>RenderGraphContext renderGraphContext</code>. This stores references to the <code>ScriptableRenderContext</code> and the <code>CommandBuffer</code> that provide utility functions and allow you to write rendering code.</li>
</ul>
<h4><a class="anchor" id="autotoc_md1640"></a>
Accessing resources in the render pass</h4>
<p>Inside the rendering function, you can access all the render graph resource handles stored inside the <code>passData</code>. The conversion to actual resources is automatic so, whenever a function needs an RTHandle, a ComputeBuffer, or a RendererList, you can pass the handle and the render graph converts the handle to the actual resource implicitly. Note that doing such implicit conversion outside of a rendering function results in an exception. This exception occurs because, outside of rendering, the render graph may have not allocated those resources yet.</p>
<h4><a class="anchor" id="autotoc_md1641"></a>
Using the RenderGraphContext</h4>
<p>The RenderGraphContext provides various functionality you need to write rendering code. The two most important are the <code>ScriptableRenderContext</code> and the <code>CommandBuffer</code>, which you use to call all rendering commands.</p>
<p>The RenderGraphContext also contains the <code>RenderGraphObjectPool</code>. This class helps you to manage temporary objects that you might need for rendering code.</p>
<h4><a class="anchor" id="autotoc_md1642"></a>
Get temp functions</h4>
<p>Two functions that are particularly useful during render passes are <code>GetTempArray</code> and <code>GetTempMaterialPropertyBlock</code>.</p>
<div class="fragment"><div class="line"><span class="preprocessor"> #</span></div>
<div class="line">T[] GetTempArray&lt;T&gt;(<span class="keywordtype">int</span> size);</div>
<div class="line">MaterialPropertyBlock GetTempMaterialPropertyBlock();</div>
</div><!-- fragment --><p><code>GetTempArray</code> returns a temporary array of type <code>T</code> and size <code>size</code>. This can be useful to allocate temporary arrays for passing parameters to materials or creating a <code>RenderTargetIdentifier</code> array to create multiple render target setups without the need to manage the array’s lifetime yourself.</p>
<p><code>GetTempMaterialPropertyBlock</code> returns a clean material property block that you can use to set up parameters for a Material. This is particularly important because more than one pass might use a material and each pass could use it with different parameters. Because the rendering code execution is deferred via command buffers, copying material property blocks into the command buffer is mandatory to preserve data integrity on execution.</p>
<p>The render graph releases and pools all the resources these two functions return automatically after the pass execution. This means you don’t have to manage them yourself and does not create garbage.</p>
<h3><a class="anchor" id="autotoc_md1643"></a>
Example render pass</h3>
<p>The following code example contains a render pass with a setup and render function:</p>
<div class="fragment"><div class="line"><span class="preprocessor"> #</span></div>
<div class="line"><a class="code hl_struct" href="structUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1TextureHandle.html">TextureHandle</a> MyRenderPass(<a class="code hl_class" href="classUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1RenderGraph.html">RenderGraph</a> renderGraph, <a class="code hl_struct" href="structUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1TextureHandle.html">TextureHandle</a> inputTexture, <span class="keywordtype">float</span> parameter, Material material)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> (var builder = renderGraph.AddRenderPass&lt;MyRenderPassData&gt;(<span class="stringliteral">&quot;My Render Pass&quot;</span>, out var passData))</div>
<div class="line">    {</div>
<div class="line">        passData.parameter = parameter;</div>
<div class="line">        passData.material = material;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Tells the graph that this pass will read inputTexture.</span></div>
<div class="line">        passData.inputTexture = builder.ReadTexture(inputTexture);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Creates the output texture.</span></div>
<div class="line">        <a class="code hl_struct" href="structUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1TextureHandle.html">TextureHandle</a> output = renderGraph.<a class="code hl_function" href="classUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1RenderGraph.html#a52b03077017a036a3b11864e67f7c7ed">CreateTexture</a>(<span class="keyword">new</span> <a class="code hl_struct" href="structUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1TextureDesc.html">TextureDesc</a>(Vector2.one, <span class="keyword">true</span>, <span class="keyword">true</span>)</div>
<div class="line">                        { colorFormat = GraphicsFormat.R8G8B8A8_UNorm, clearBuffer = true, clearColor = Color.black, name = <span class="stringliteral">&quot;Output&quot;</span> });</div>
<div class="line">        <span class="comment">// Tells the graph that this pass will write this texture and needs to be set as render target 0.</span></div>
<div class="line">        passData.outputTexture = builder.UseColorBuffer(output, 0);</div>
<div class="line"> </div>
<div class="line">        builder.SetRenderFunc(</div>
<div class="line">        (MyRenderPassData data, <a class="code hl_class" href="classUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1RenderGraphContext.html">RenderGraphContext</a> ctx) =&gt;</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// Render Target is already set via the use of UseColorBuffer above.</span></div>
<div class="line">            <span class="comment">// If builder.WriteTexture was used, you&#39;d need to do something like that:</span></div>
<div class="line">            <span class="comment">// CoreUtils.SetRenderTarget(ctx.cmd, data.output);</span></div>
<div class="line"> </div>
<div class="line">            <span class="comment">// Setup material for rendering</span></div>
<div class="line">            var materialPropertyBlock = ctx.<a class="code hl_variable" href="classUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1RenderGraphContext.html#af765352098bf2e89a6af2dac5071b4aa">renderGraphPool</a>.<a class="code hl_function" href="classUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1RenderGraphObjectPool.html#abc37f856e524a086dbbc1fefbf40131e">GetTempMaterialPropertyBlock</a>();</div>
<div class="line">            materialPropertyBlock.SetTexture(<span class="stringliteral">&quot;_MainTexture&quot;</span>, data.input);</div>
<div class="line">            materialPropertyBlock.SetFloat(<span class="stringliteral">&quot;_FloatParam&quot;</span>, data.parameter);</div>
<div class="line"> </div>
<div class="line">            CoreUtils.DrawFullScreen(ctx.<a class="code hl_variable" href="classUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1RenderGraphContext.html#ae9dca4dbfff9972bb274f0d497c90493">cmd</a>, data.material, materialPropertyBlock);</div>
<div class="line">        });</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">return</span> output;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclassUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1RenderGraphContext_html_ae9dca4dbfff9972bb274f0d497c90493"><div class="ttname"><a href="classUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1RenderGraphContext.html#ae9dca4dbfff9972bb274f0d497c90493">UnityEngine.Experimental.Rendering.RenderGraphModule.RenderGraphContext.cmd</a></div><div class="ttdeci">CommandBuffer cmd</div><div class="ttdoc">summary&gt;Render Graph pool used for temporary data.</div><div class="ttdef"><b>Definition</b> RenderGraph.cs:35</div></div>
<div class="ttc" id="aclassUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1RenderGraphContext_html_af765352098bf2e89a6af2dac5071b4aa"><div class="ttname"><a href="classUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1RenderGraphContext.html#af765352098bf2e89a6af2dac5071b4aa">UnityEngine.Experimental.Rendering.RenderGraphModule.RenderGraphContext.renderGraphPool</a></div><div class="ttdeci">RenderGraphObjectPool renderGraphPool</div><div class="ttdoc">summary&gt;Render Graph default resources.</div><div class="ttdef"><b>Definition</b> RenderGraph.cs:37</div></div>
<div class="ttc" id="aclassUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1RenderGraphObjectPool_html_abc37f856e524a086dbbc1fefbf40131e"><div class="ttname"><a href="classUnityEngine_1_1Experimental_1_1Rendering_1_1RenderGraphModule_1_1RenderGraphObjectPool.html#abc37f856e524a086dbbc1fefbf40131e">UnityEngine.Experimental.Rendering.RenderGraphModule.RenderGraphObjectPool.GetTempMaterialPropertyBlock</a></div><div class="ttdeci">MaterialPropertyBlock GetTempMaterialPropertyBlock()</div><div class="ttdoc">Allocate a temporary MaterialPropertyBlock for the Render Pass.</div><div class="ttdef"><b>Definition</b> RenderGraphObjectPool.cs:86</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1644"></a>
Ending the frame</h2>
<p>Over the course of your application, the render graph needs to allocate various resources. It might use these resources for a time but then might not need them. For the graph to free up those resources, call the <code>EndFrame()</code> method once a frame. This deallocates any resources that the render graph has not used since the last frame. This also executes all internal processing the render graph requires at the end of the frame.</p>
<p>Note that you should only call this once per frame and after all the rendering is complete (for example, after the last camera renders). This is because different cameras might have different rendering paths and thus need different resources. Calling the purge after each camera could result in the render graph releasing resources too early even though they might be necessary for the next camera. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
